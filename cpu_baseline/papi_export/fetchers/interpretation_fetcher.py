import logging
from typing import Dict, List, Optional, Any, Tuple
import numpy as np

from ..utils import extract_val

logger = logging.getLogger(__name__)


class InterpretationFetcher:
    """Fetcher for interpretations and horizons data"""

    def __init__(self, config, api_connector, ng_logger=None):
        self.config = config
        self.api = api_connector
        self.ng_logger = ng_logger  # Save for error logging
        self.interpretation_name = config.source_interpretation_name
        
    def fetch_interpretation_data(
        self,
        well_uuid: str,
        well_trajectory: List[Dict],
        tops_data: List[Dict],
        interpretation_name: Optional[str] = None  # NEW PARAMETER
    ) -> Optional[Dict[str, Any]]:
        """Fetch interpretation and horizons data for well with shift correction"""
        logger.info(f"Fetching interpretations for well {well_uuid}")

        # Determine which interpretation to search for
        if interpretation_name is None or interpretation_name.strip() == "" or interpretation_name.lower() == "starred":
            # Search for starred interpretation
            logger.info("Searching for starred interpretation")
            source_interpretation = self._get_starred_interpretation(well_uuid)

            if not source_interpretation:
                # âŒ NO FALLBACK - fail immediately with error
                logger.error("Starred interpretation not found for well")
                if self.ng_logger:
                    self.ng_logger.log_error("interpretation_fetcher",
                                           "Starred interpretation not found", {
                                               "well_uuid": well_uuid,
                                               "search_type": "starred"
                                           })
                raise ValueError(f"Starred interpretation not found for well {well_uuid}")
        else:
            # Search by name
            logger.info(f"Searching for interpretation by name: '{interpretation_name}'")
            source_interpretation = self._find_interpretation_by_name(well_uuid, interpretation_name)

            if not source_interpretation:
                # âŒ NO FALLBACK - fail immediately with error
                available = [interp['name'] for interp in self.api.get_interpretations_by_well(well_uuid)]
                if self.ng_logger:
                    self.ng_logger.log_error("interpretation_fetcher",
                                           f"Interpretation '{interpretation_name}' not found", {
                                               "well_uuid": well_uuid,
                                               "requested_interpretation": interpretation_name,
                                               "search_type": "by_name",
                                               "available_interpretations": available
                                           })
                raise ValueError(f"Interpretation '{interpretation_name}' not found. Available: {', '.join(available)}")

        interp_uuid = source_interpretation['uuid']
        interp_name = source_interpretation['name']

        logger.info(f"Using source interpretation '{interp_name}' ({interp_uuid})")
        
        # Get horizons data with specified spacing
        horizons_data = self.api.get_horizons_data(
            interp_uuid, 
            self.config.horizon_spacing
        )
        
        # Extract horizon TVDSS values
        horizon_tvdss_data, available_horizons = self._extract_horizon_tvdss(
            horizons_data,
            self.config.horizon_name
        )

        return {
            'interpretation_uuid': interp_uuid,
            'interpretation_name': interp_name,
            'horizons_raw_data': horizons_data,
            'horizon_tvdss': horizon_tvdss_data,
            'available_horizons': available_horizons,  # List of all horizons found
            'segments': [],  # Will be generated by new algorithm
            'shift_offset': 0.0  # Will be calculated by new algorithm
        }
        
    def _extract_horizon_tvdss(
        self, horizons_data: Dict, target_horizon_name: str
    ) -> tuple[Optional[List[Dict]], List[str]]:
        """Extract TVDSS values for specific horizon - simple version

        Returns:
            tuple: (horizon_points or None, list of available horizon names)
        """

        content = horizons_data['content']
        if not content:
            logger.warning("No horizons data content")
            return None, []

        horizon_points = []
        available_horizons = set()  # Use set to avoid duplicates

        # Extract all horizon points
        for point in content:
            md = extract_val(point['md'])
            tvt = extract_val(point.get('tvt', {})) or 0.0
            vs = extract_val(point.get('vs_azim', {}).get('vs', {})) or 0.0

            # Find target horizon in this point
            horizons = point['horizons']
            for horizon in horizons:
                # Collect all available horizon names
                available_horizons.add(horizon['name'])

                if horizon['name'] == target_horizon_name:
                    tvdss = extract_val(horizon['tvdss'])
                    horizon_points.append({
                        'md': md,
                        'tvdss': tvdss,
                        'tvt': tvt,
                        'vs': vs
                    })
                    break

        available_horizons_list = sorted(list(available_horizons))

        if not horizon_points:
            logger.warning(f"Horizon '{target_horizon_name}' not found in data")
            logger.warning(f"Available horizons: {', '.join(available_horizons_list)}")
            return None, available_horizons_list

        logger.info(f"Extracted {len(horizon_points)} points for horizon '{target_horizon_name}'")

        return horizon_points, available_horizons_list

    def _get_starred_interpretation(self, well_uuid: str) -> Optional[Dict]:
        """Get starred interpretation"""
        try:
            starred_data = self.api.get_starred_interpretation(well_uuid)
            logger.info(f"ðŸ” RAW starred API response for well {well_uuid}: {starred_data}")
            logger.info(f"ðŸ” Starred data type: {type(starred_data)}, keys: {starred_data.keys() if isinstance(starred_data, dict) else 'N/A'}")

            if not starred_data:
                logger.warning(f"âš ï¸ Starred data is None or empty for well {well_uuid}")
                return None

            starred_uuid = starred_data.get('uuid')
            if not starred_uuid:
                logger.warning(f"âš ï¸ No 'uuid' key in starred_data for well {well_uuid}. Full data: {starred_data}")
                return None

            logger.info(f"âœ… Found starred UUID: {starred_uuid}")

            interpretation_data = self.api.get_interpretation_by_uuid(well_uuid, starred_uuid)
            logger.info(f"ðŸ” RAW interpretation API response for UUID {starred_uuid}: {interpretation_data}")
            logger.info(f"ðŸ” Interpretation data type: {type(interpretation_data)}, keys: {interpretation_data.keys() if isinstance(interpretation_data, dict) else 'N/A'}")

            if not interpretation_data:
                logger.warning(f"âš ï¸ Interpretation data is None for UUID: {starred_uuid}")
                return None

            interp_name = interpretation_data.get('name', 'Starred Interpretation')
            logger.info(f"âœ… Found starred interpretation: '{interp_name}' ({starred_uuid})")

            return {
                'uuid': starred_uuid,
                'name': interp_name
            }
        except Exception as e:
            logger.error(f"âŒ Exception in _get_starred_interpretation for well {well_uuid}")
            logger.error(f"âŒ Exception type: {type(e).__name__}")
            logger.error(f"âŒ Exception message: {e}")
            import traceback
            logger.error(f"âŒ Full traceback:\n{traceback.format_exc()}")
            return None

    def _find_interpretation_by_name(self, well_uuid: str, name: str) -> Optional[Dict]:
        """Find interpretation by name"""
        interpretations = self.api.get_interpretations_by_well(well_uuid)

        for interp in interpretations:
            if interp['name'].lower() == name.lower():
                return {
                    'uuid': interp['uuid'],
                    'name': interp['name']
                }
        return None